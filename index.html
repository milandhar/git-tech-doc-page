<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="/style.css">
    <title>Git Technical Documentation Page</title>
  </head>
  <body>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"> </script>
    <h1>Git Documentation</h1>
    <main id = "main-doc">
      <section class = "main-section" id = "intro">
        <header>
          Introduction
        </header>
        <article>
        <p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.
        </p>
        <p>Most operations in Git need only local files and resources to operate — generally no information is needed from another computer on your network. If you’re used to a CVCS where most operations have that network latency overhead, this aspect of Git will make you think that the gods of speed have blessed Git with unworldly powers. Because you have the entire history of the project right there on your local disk, most operations seem almost instantaneous.
        </p>
        <p>Everything in Git is checksummed before it is stored and is then referred to by that checksum. This means it’s impossible to change the contents of any file or directory without Git knowing about it. This functionality is built into Git at the lowest levels and is integral to its philosophy. You can’t lose information in transit or get file corruption without Git being able to detect it.
        </p>
        <p>When you do actions in Git, nearly all of them only add data to the Git database. It is hard to get the system to do anything that is not undoable or to make it erase data in any way. As with any VCS, you can lose or mess up changes you haven’t committed yet, but after you commit a snapshot into Git, it is very difficult to lose, especially if you regularly push your database to another repository.
        </p>
        <p> <b>Pay attention now</b> — here is the main thing to remember about Git if you want the rest of your learning process to go smoothly. Git has three main states that your files can reside in: committed, modified, and staged:
          <ul>
            <li>Committed means that the data is safely stored in your local database.</li>
            <li>Modified means that you have changed the file but have not committed it to your database yet.</li>
            <li>Staged means that you have marked a modified file in its current version to go into your next commit snapshot.</li>
          </ul>
        </p>

        <p>
          The basic Git workflow goes something like this:
          </p>
          <ol>
            <li>You modify files in your working tree.</li>
            <li>You selectively stage just those changes you want to be part of your next commit, which adds only those changes to the staging area.</li>
            <li>You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.</li>
          </ol>
          <p>
          If a particular version of a file is in the Git directory, it’s considered committed. If it has been modified and was added to the staging area, it is staged. And if it was changed since it was checked out but has not been staged, it is modified.
          </p>
          </article>
      </section>

      <section class = "main-section" id = "getting_repo">
        <header>
          Git Basics - Getting a Git Repository
        </header>
        <article>
        <p>If you can read only one chapter to get going with Git, this is it. This chapter covers every basic command you need to do the vast majority of the things you’ll eventually spend your time doing with Git. By the end of the chapter, you should be able to configure and initialize a repository, begin and stop tracking files, and stage and commit changes. </p>
        <p>You typically obtain a Git repository in one of two ways:</p>
        <ol>
          <li>You can take a local directory that is currently not under version control, and turn it into a Git repository, or</li>
          <li>You can clone an existing Git repository from <i>elsewhere</i>.</li>
        </ol>
        <h3>Initializing a Repository in an Existing Directory</h3>
        <p>If you have a project directory that is currently not under version control and you want to start controlling it with Git, you first need to go to that project’s directory.
          <br>
          for macOS:
          <br>
          <code>$ cd /c/user/my_project</code>
          and type:
          <code>$ git init</code>
        </p>
        <p>If you want to start version-controlling existing files (as opposed to an empty directory), you should probably begin tracking those files and do an initial commit. You can accomplish that with a few git add commands that specify the files you want to track, followed by a git commit:</p>
        <h3>Cloning an Existing Repository</h3>
        <p>If you want to get a copy of an existing Git repository — for example, a project you’d like to contribute to — the command you need is <code>git clone &lt;url&gt;</code>.</p>

        <section class = "main-section" id = "tracking_files">
          <header>
          Tracking New Files
          </header>
          <article class="">
            <p>In order to begin tracking a new file, you use the command git add. To begin tracking the README file, you can run this:</p>
            <code>$ git add README</code>
            <p>If you run your status command again, you can see that your README file is now tracked and staged to be committed:</p>
            <code>
              $ git status
              On branch master
              Your branch is up-to-date with 'origin/master'.
              Changes to be committed:
                (use "git reset HEAD &lt;file&gt;..." to unstage)

                  new file:   README
            </code>
          </article>
        </section>

        <section class = "main-section" id = "staging_files">
          <header>
            Staging Modified Files
          </header>
          <article>
            <p>To stage a new file, you run the <code>git add</code> command. <code>git add</code> is a multipurpose command — you use it to begin tracking new files, to stage files, and to do other things like marking merge-conflicted files as resolved. It may be helpful to think of it more as “add precisely this content to the next commit” rather than “add this file to the project”. </p>
            <p>To see what you’ve changed but not yet staged, type <code>git diff</code> with no other arguments. That command compares what is in your working directory with what is in your staging area. The result tells you the changes you’ve made that you haven’t yet staged.</p>
            <p>It’s important to note that git diff by itself doesn’t show all changes made since your last commit — only changes that are still unstaged. If you’ve staged all of your changes, <code>git diff</code> will give you no output.</p>
          </article>
          </section>

          <section class = "main-section" id = "committing_changes">
            <header>
              Committing Your Changes
            </header>
            <article>
              <p>Now that your staging area is set up the way you want it, you can commit your changes. Remember that anything that is still unstaged — any files you have created or modified that you haven’t run git add on since you edited them — won’t go into this commit. They will stay as modified files on your disk. In this case, let’s say that the last time you ran git status, you saw that everything was staged, so you’re ready to commit your changes. The simplest way to commit is to type <code>git commit:</code></p>
              <p>Alternatively, you can type your commit message inline with the commit command by specifying it after a <code>-m</code> flag</p>
            </article>
          </section>

          <section class = "main-section" id = "removing_files">
            <header>
              Removing Files
            </header>
            <article class="">
              <p>To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit. The <code>git rm</code> command does that, and also removes the file from your working directory so you don’t see it as an untracked file the next time around.
                If you modified the file or had already added it to the staging area, you must force the removal with the <code>-f</code> option. This is a safety feature to prevent accidental removal of data that hasn’t yet been recorded in a snapshot and that can’t be recovered from Git.
              </p>
              <p>Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area. In other words, you may want to keep the file on your hard drive but not have Git track it anymore. This is particularly useful if you forgot to add something to your .gitignore file and accidentally staged it, like a large log file or a bunch of .a compiled files. To do this, use the --cached option:
                 <code>$ git rm --cached README</code></p>
            </article>
          </section>

        <section class = "main-section" id = "moving_files">
        <header>
          Moving Files
        </header>
        <article>
          <p>If you want to rename a file in Git, you can run something like:</p>
          <code>$ git mv file_from file_to</code>
        </article>
      </section>

      <section class = "main-section" id = "undoing_things">
        <header>
          Undoing Things
        </header>
        <article>
          <p>At any stage, you may want to undo something. Be careful, because you can’t always undo some of these undos. This is one of the few areas in Git where you may lose some work if you do it wrong.</p>

          <p>One of the common undos takes place when you commit too early and possibly forget to add some files, or you mess up your commit message. If you want to redo that commit, make the additional changes you forgot, stage them, and commit again using the <code>--amend</code> option:</p>
          <code>$ git commit --amend</code>
          <p>As an example, if you commit and then realize you forgot to stage the changes in a file you wanted to add to this commit, you can do something like this:</p>
          <code>
            $ git commit -m 'initial commit'
            $ git add forgotten_file
            $ git commit --amend
          </code>

        </article>
      </section>

      <section class = "main-section" id = "showing_remotes">
        <header>
          Showing Your Remotes
        </header>
        <article>
          <p>To see which remote servers you have configured, you can run the <code>git remote</code> command. It lists the shortnames of each remote handle you’ve specified. If you’ve cloned your repository, you should at least see <code>origin</code> — that is the default name Git gives to the server you cloned from</p>
        </article>
      </section>

      <section class = "main-section" id = "fetching_pulling_from_remotes">
        <header>
          Fetching and Pulling from Your Remotes
        </header>
        <article>
          <p>To get data from your remote projects, you can run:</p>
          <code>$ git fetch &lt;remote&gt;</code>
          <p>The command goes out to that remote project and pulls down all the data from that remote project that you don’t have yet. After you do this, you should have references to all the branches from that remote, which you can merge in or inspect at any time.</p>
          <p>If you clone a repository, the command automatically adds that remote repository under the name “origin”. So, <code>git fetch origin</code> fetches any new work that has been pushed to that server since you cloned (or last fetched from) it. It’s important to note that the <code>git fetch</code> command only downloads the data to your local repository — it doesn’t automatically merge it with any of your work or modify what you’re currently working on. You have to merge it manually into your work when you’re ready.</p>
          <p>If your current branch is set up to track a remote branch, you can use the <code>git pull</code> command to automatically fetch and then merge that remote branch into your current branch.</p>
        </article>
      </section>

      <section class = "main-section" id = "pushing_to_remotes">
        <header>
          Pushing to Your Remotes
        </header>
        <article>
          <p>When you have your project at a point that you want to share, you have to push it upstream. The command for this is simple: <code>git push &lt;remote&gt; &lt;branch&gt;</code>. If you want to push your master branch to your origin server (again, cloning generally sets up both of those names for you automatically), then you can run this to push any commits you’ve done back up to the server:</p>
          <code>$ git push origin master</code>
        </article>
      </section>

      <section class = "main-section" id = "creating_new_branch">
        <header>
          Creating a New Branch
        </header>
        <article>
          <img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="Commits and their parents">
          <p>A branch in Git is simply a lightweight movable pointer to one of these commits. The default branch name in Git is master. As you start making commits, you’re given a master branch that points to the last commit you made. Every time you commit, the master branch pointer moves forward automatically.</p>
          <img src="https://git-scm.com/book/en/v2/images/branch-and-history.png" alt="A branch and its commit history">
          <p>What happens when you create a new branch? Well, doing so creates a new pointer for you to move around. Let’s say you want to create a new branch called testing. You do this with the <code>git branch</code> command:</p>
          <code>$ git branch testing</code>
          <p>How does Git know what branch you’re currently on? It keeps a special pointer called HEAD. Note that this is a lot different than the concept of HEAD in other VCSs you may be used to, such as Subversion or CVS. In Git, this is a pointer to the local branch you’re currently on. In this case, you’re still on master. The git branch command only created a new branch — it didn’t switch to that branch.</p>
          <img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD pointing to a branch">
          <p>You can easily see this by running a simple git log command that shows you where the branch pointers are pointing. This option is called --decorate.</p>
          <code>$ git log --oneline --decorate
          f30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central interface
          34ac2 Fixed bug #1328 - stack overflow under certain conditions
          98ca9 The initial commit of my project
          </code>
        </article>
      </section>

      <section class = "main-section" id = "switching_branches">
        <header>
          Switching Branches
        </header>
        <article>
          <p>To switch to an existing branch, you run the <code>git checkout</code> command. Let’s switch to the new testing branch:</p>
          <code>$ git checkout testing</code>
        </article>
      </section>

      <section class = "main-section" id = "basic_merging">
        <header>
          Basic Merging
        </header>
        <article>
          <p>Suppose you’ve decided that your issue #53 work is complete and ready to be merged into your master branch. In order to do that, you’ll merge your iss53 branch into master, much like you merged your hotfix branch earlier. All you have to do is check out the branch you wish to merge into and then run the <code>git merge</code> command:</p>
          <code>
            $ git checkout master
            Switched to branch 'master'
            $ git merge iss53
            Merge made by the 'recursive' strategy.
            index.html |    1 +
            1 file changed, 1 insertion(+)
          </code>
          <p>This looks a bit different than the hotfix merge you did earlier. In this case, your development history has diverged from some older point. Because the commit on the branch you’re on isn’t a direct ancestor of the branch you’re merging in, Git has to do some work. In this case, Git does a simple three-way merge, using the two snapshots pointed to by the branch tips and the common ancestor of the two.</p>
            <img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="Three snapshots used in a typical merge">
          <p>Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it. This is referred to as a merge commit, and is special in that it has more than one parent.</p>
            <img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="A merge commit">
        </article>
      </section>

      <section class = "main-section" id = "basic_merge_conflicts">
        <header>
          Basic Merge Conflicts
        </header>
        <article>
        </article>
      </section>

      <section class = "main-section" id = "basic_merge_conflicts">
        <header>
          Basic Merge Conflicts
        </header>
        <article>
        </article>
      </section>

      <section class = "main-section" id = "basic_merge_conflicts">
        <header>
          Basic Merge Conflicts
        </header>
        <article>
        </article>
      </section>

    </main>
  </body>
</html>
